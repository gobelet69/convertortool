{"version":3,"sources":["../src/types.ts"],"names":["ConversionErrorCode","LOKDocumentType"],"mappings":"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","file":"types-entry.js","sourcesContent":["/**\n * LibreOffice WASM Document Conversion Types\n * Headless document format conversion toolkit\n */\n\n/**\n * Supported input document formats\n */\nexport type InputFormat =\n  // Microsoft Office formats\n  | 'doc'\n  | 'docx'\n  | 'xls'\n  | 'xlsx'\n  | 'ppt'\n  | 'pptx'\n  // OpenDocument formats\n  | 'odt'\n  | 'ods'\n  | 'odp'\n  | 'odg'\n  | 'odf'\n  // Other formats\n  | 'rtf'\n  | 'txt'\n  | 'html'\n  | 'htm'\n  | 'csv'\n  | 'xml'\n  | 'epub'\n  | 'pdf';\n\n/**\n * Supported output document formats\n */\nexport type OutputFormat =\n  | 'pdf'\n  | 'docx'\n  | 'doc'\n  | 'odt'\n  | 'rtf'\n  | 'txt'\n  | 'html'\n  | 'xlsx'\n  | 'xls'\n  | 'ods'\n  | 'csv'\n  | 'pptx'\n  | 'ppt'\n  | 'odp'\n  | 'png'\n  | 'jpg'\n  | 'svg';\n\n/**\n * Document conversion options\n */\nexport interface ConversionOptions {\n  /**\n   * Output format for the conversion\n   */\n  outputFormat: OutputFormat;\n\n  /**\n   * Input format hint (auto-detected if not provided)\n   */\n  inputFormat?: InputFormat;\n\n  /**\n   * PDF-specific options\n   */\n  pdf?: PdfOptions;\n\n  /**\n   * Image output options (for png, jpg, svg)\n   */\n  image?: ImageOptions;\n\n  /**\n   * Password for encrypted documents\n   */\n  password?: string;\n}\n\n/**\n * PDF-specific conversion options\n */\nexport interface PdfOptions {\n  /**\n   * PDF/A conformance level\n   */\n  pdfaLevel?: 'PDF/A-1b' | 'PDF/A-2b' | 'PDF/A-3b';\n\n  /**\n   * PDF quality (0-100, affects image compression)\n   * @default 90\n   */\n  quality?: number;\n}\n\n/**\n * Image output options\n */\nexport interface ImageOptions {\n  /**\n   * Image width in pixels\n   */\n  width?: number;\n\n  /**\n   * Image height in pixels\n   */\n  height?: number;\n\n  /**\n   * DPI for rendering\n   * @default 150\n   */\n  dpi?: number;\n\n  /**\n   * Page index to export (0-based). Only exports this single page.\n   * If not specified, exports the first page (page 0).\n   * Cannot be used together with `pages`.\n   */\n  pageIndex?: number;\n\n  /**\n   * Array of page indices to export (0-based).\n   * If specified, returns an array of results (one per page).\n   * Cannot be used together with `pageIndex`.\n   */\n  pages?: number[];\n}\n\n/**\n * Result of a document conversion\n */\nexport interface ConversionResult {\n  /**\n   * The converted document data\n   */\n  data: Uint8Array;\n\n  /**\n   * MIME type of the output\n   */\n  mimeType: string;\n\n  /**\n   * Suggested filename with new extension\n   */\n  filename: string;\n\n  /**\n   * Conversion duration in milliseconds\n   */\n  duration: number;\n}\n\n/**\n * WASM loader module interface\n * This is the interface for the loader.cjs module that creates the Emscripten module\n */\nexport interface WasmLoaderModule {\n  createModule: (config: Record<string, unknown>) => Promise<EmscriptenModule>;\n}\n\n/**\n * LibreOffice WASM module initialization options (Node.js)\n */\nexport interface LibreOfficeWasmOptions {\n  /**\n   * Path to WASM files directory\n   * @default './wasm'\n   */\n  wasmPath?: string;\n\n  /**\n   * Path to the worker script (for WorkerConverter)\n   * When not specified, auto-detected based on module location\n   */\n  workerPath?: string;\n\n  /**\n   * Pre-loaded WASM loader module\n   * When provided, bypasses dynamic require of loader.cjs\n   * This is useful for bundlers like Turbopack that can't handle dynamic requires\n   *\n   * @example\n   * ```typescript\n   * // In your code, import the loader statically\n   * import * as wasmLoader from '@matbee/libreoffice-converter/wasm/loader.cjs';\n   *\n   * const converter = new LibreOfficeConverter({\n   *   wasmPath: './wasm',\n   *   wasmLoader,\n   * });\n   * ```\n   */\n  wasmLoader?: WasmLoaderModule;\n\n  /**\n   * Enable verbose logging\n   * @default false\n   */\n  verbose?: boolean;\n\n  /**\n   * Called when WASM module is ready\n   */\n  onReady?: () => void;\n\n  /**\n   * Called on initialization error\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Called with progress updates during initialization\n   */\n  onProgress?: (progress: ProgressInfo) => void;\n}\n\n/**\n * Explicit paths to WASM files (Browser)\n * All paths are required when specified explicitly\n */\nexport interface BrowserWasmPaths {\n  /** URL to soffice.js - the main Emscripten loader script */\n  sofficeJs: string;\n  /** URL to soffice.wasm - the WebAssembly binary (~112MB) */\n  sofficeWasm: string;\n  /** URL to soffice.data - the virtual filesystem image (~80MB) */\n  sofficeData: string;\n  /** URL to soffice.worker.js - the Emscripten pthread worker */\n  sofficeWorkerJs: string;\n}\n\n/**\n * Browser converter initialization options\n * All WASM paths are optional and default to /wasm/ via createWasmPaths()\n */\nexport interface BrowserConverterOptions {\n  /** URL to soffice.js - defaults to /wasm/soffice.js */\n  sofficeJs?: string;\n  /** URL to soffice.wasm - defaults to /wasm/soffice.wasm */\n  sofficeWasm?: string;\n  /** URL to soffice.data - defaults to /wasm/soffice.data */\n  sofficeData?: string;\n  /** URL to soffice.worker.js - defaults to /wasm/soffice.worker.js */\n  sofficeWorkerJs?: string;\n\n  /**\n   * Enable verbose logging\n   * @default false\n   */\n  verbose?: boolean;\n\n  /**\n   * Called when WASM module is ready\n   */\n  onReady?: () => void;\n\n  /**\n   * Called on initialization error\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Called with progress updates during initialization\n   */\n  onProgress?: (progress: WasmLoadProgress) => void;\n}\n\n/**\n * Worker browser converter initialization options\n * All WASM paths are optional and default to /wasm/ via createWasmPaths()\n */\nexport interface WorkerBrowserConverterOptions extends BrowserConverterOptions {\n  /** URL to browser.worker.js - defaults to /dist/browser.worker.global.js */\n  browserWorkerJs?: string;\n  /**\n   * Enable download progress tracking during WASM initialization\n   * When enabled, intercepts fetch/XHR to track download progress for soffice.wasm and soffice.data\n   * \n   * **WARNING**: This is disabled by default because the fetch interceptor can break\n   * WebAssembly streaming compilation in some environments. Only enable if you need\n   * detailed download progress and have tested it works in your target browsers.\n   * \n   * @default false\n   */\n  enableProgressTracking?: boolean;\n}\n\n/**\n * Internal type for BrowserConverterOptions after defaults are applied\n * All WASM paths are guaranteed to be defined\n */\nexport type ResolvedBrowserConverterOptions = BrowserConverterOptions & BrowserWasmPaths;\n\n/**\n * Internal type for WorkerBrowserConverterOptions after defaults are applied\n * All WASM paths and browserWorkerJs are guaranteed to be defined\n */\nexport type ResolvedWorkerBrowserConverterOptions = WorkerBrowserConverterOptions & BrowserWasmPaths & {\n  browserWorkerJs: string;\n};\n\n/**\n * Default URL for WASM files - relative path for same-origin hosting\n * Users typically serve WASM files from their own server at /wasm/\n */\nexport const DEFAULT_WASM_BASE_URL = '/wasm/';\n\n/**\n * Create WASM file paths from a base URL\n * Convenience helper for users who keep all WASM files in one directory\n *\n * @param baseUrl - Base URL ending with '/' (e.g., '/wasm/', 'https://cdn.example.com/wasm/')\n *                  Defaults to '/wasm/' for same-origin hosting\n * @returns Object with all WASM file paths\n *\n * @example\n * ```typescript\n * // Use default /wasm/ path (same-origin)\n * const converter = new WorkerBrowserConverter({\n *   ...createWasmPaths(),\n *   browserWorkerJs: '/dist/browser.worker.js',\n * });\n *\n * // Or use your own CDN\n * const converter = new WorkerBrowserConverter({\n *   ...createWasmPaths('https://cdn.example.com/wasm/'),\n *   browserWorkerJs: '/dist/browser.worker.js',\n * });\n * ```\n */\nexport function createWasmPaths(baseUrl: string = DEFAULT_WASM_BASE_URL): BrowserWasmPaths {\n  // Ensure baseUrl ends with /\n  const base = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;\n  return {\n    sofficeJs: `${base}soffice.js`,\n    sofficeWasm: `${base}soffice.wasm`,\n    sofficeData: `${base}soffice.data`,\n    sofficeWorkerJs: `${base}soffice.worker.js`,\n  };\n}\n\n/**\n * Loading phases for WASM initialization\n * Used to track detailed progress during the ~80 second browser startup\n */\nexport type WasmLoadPhase =\n  | 'download-wasm'    // Downloading soffice.wasm (~142MB)\n  | 'download-data'    // Downloading soffice.data (~96MB)\n  | 'compile'          // WebAssembly compilation\n  | 'filesystem'       // Emscripten filesystem setup\n  | 'lok-init'         // LibreOfficeKit initialization\n  | 'ready' | 'starting' | 'loading' | 'initializing' | 'converting' | 'complete';           // Complete\n\n/**\n * Extended progress information with download details\n * Backward compatible - existing code using percent/message continues to work\n */\nexport interface WasmLoadProgress {\n  /** Overall progress 0-100 */\n  percent: number;\n  /** Human-readable status message */\n  message: string;\n  /** Current loading phase */\n  phase: WasmLoadPhase;\n  /** Bytes downloaded (present during download phases) */\n  bytesLoaded?: number;\n  /** Total bytes to download (present during download phases) */\n  bytesTotal?: number;\n}\n\n/**\n * Progress information\n * @deprecated Use WasmLoadProgress for richer progress data\n */\nexport interface ProgressInfo {\n  phase: 'loading' | 'initializing' | 'converting' | 'complete';\n  percent: number;\n  message: string;\n}\n\n/**\n * Error codes for conversion failures\n */\nexport enum ConversionErrorCode {\n  UNKNOWN = 'UNKNOWN',\n  INVALID_INPUT = 'INVALID_INPUT',\n  UNSUPPORTED_FORMAT = 'UNSUPPORTED_FORMAT',\n  CORRUPTED_DOCUMENT = 'CORRUPTED_DOCUMENT',\n  PASSWORD_REQUIRED = 'PASSWORD_REQUIRED',\n  WASM_NOT_INITIALIZED = 'WASM_NOT_INITIALIZED',\n  CONVERSION_FAILED = 'CONVERSION_FAILED',\n  LOAD_FAILED = 'LOAD_FAILED',\n}\n\n/**\n * Custom error class for conversion errors\n */\nexport class ConversionError extends Error {\n  public readonly code: ConversionErrorCode;\n  public readonly details?: string;\n\n  constructor(code: ConversionErrorCode, message: string, details?: string) {\n    super(message);\n    this.name = 'ConversionError';\n    this.code = code;\n    this.details = details;\n  }\n}\n\n/**\n * Emscripten Module interface\n */\nexport interface EmscriptenModule {\n  // Core Emscripten functions\n  ccall: (\n    name: string,\n    returnType: string | null,\n    argTypes: string[],\n    args: unknown[]\n  ) => unknown;\n  cwrap: (\n    name: string,\n    returnType: string | null,\n    argTypes: string[]\n  ) => (...args: unknown[]) => unknown;\n\n  // Memory management\n  _malloc: (size: number) => number;\n  _free: (ptr: number) => void;\n  HEAPU8: Uint8Array;\n  HEAP32: Int32Array;\n  HEAPU32: Uint32Array;\n\n  // File system\n  FS: EmscriptenFS;\n\n  // Lifecycle\n  onRuntimeInitialized?: () => void;\n  calledRun?: boolean;\n\n  // LibreOfficeKit hooks (exported C functions)\n  _lok_preinit?: (path: number, args: number) => number;\n  _lok_preinit_2?: (path: number, args: number, callback: number) => number;\n  _libreofficekit_hook?: (path: number) => number;\n  _libreofficekit_hook_2?: (path: number, userProfile: number) => number;\n  _main?: (argc: number, argv: number) => number;\n\n  // WebAssembly function table for indirect calls\n  wasmTable?: WebAssembly.Table;\n\n  // Module locator\n  locateFile?: (path: string) => string;\n  print?: (text: string) => void;\n  printErr?: (text: string) => void;\n\n  // Runtime ready promise (some builds)\n  ready?: Promise<EmscriptenModule>;\n}\n\n/**\n * Emscripten virtual filesystem\n */\nexport interface EmscriptenFS {\n  mkdir: (path: string) => void;\n  writeFile: (path: string, data: Uint8Array | string, opts?: { encoding?: string }) => void;\n  readFile: (path: string, opts?: { encoding?: string }) => Uint8Array | string;\n  unlink: (path: string) => void;\n  readdir: (path: string) => string[];\n  stat: (path: string) => { size: number; isDirectory: () => boolean };\n  rmdir: (path: string) => void;\n  rename: (oldPath: string, newPath: string) => void;\n  open: (path: string, flags: unknown, mode?: unknown) => unknown;\n}\n\n/**\n * Filter name mapping for LibreOffice export\n * Note: For image exports, use getFilterForDocType() instead as filters are document-type specific\n */\nexport const FORMAT_FILTERS: Record<OutputFormat, string> = {\n  pdf: 'writer_pdf_Export',\n  docx: 'MS Word 2007 XML',\n  doc: 'MS Word 97',\n  odt: 'writer8',\n  rtf: 'Rich Text Format',\n  txt: 'Text',\n  html: 'HTML (StarWriter)',\n  xlsx: 'Calc MS Excel 2007 XML',\n  xls: 'MS Excel 97',\n  ods: 'calc8',\n  csv: 'Text - txt - csv (StarCalc)',\n  pptx: 'Impress MS PowerPoint 2007 XML',\n  ppt: 'MS PowerPoint 97',\n  odp: 'impress8',\n  png: 'writer_png_Export',\n  jpg: 'writer_jpg_Export',\n  svg: 'writer_svg_Export',\n};\n\n/**\n * LibreOfficeKit document types (from LibreOfficeKitEnums.h)\n */\nexport enum LOKDocumentType {\n  TEXT = 0,\n  SPREADSHEET = 1,\n  PRESENTATION = 2,\n  DRAWING = 3,\n  OTHER = 4,\n}\n\n/**\n * Document-type-specific filters for image and PDF exports\n * Each document type (Writer, Calc, Impress, Draw) has its own export filters\n */\nexport const DOC_TYPE_FILTERS: Record<LOKDocumentType, Partial<Record<OutputFormat, string>>> = {\n  [LOKDocumentType.TEXT]: {\n    pdf: 'writer_pdf_Export',\n    png: 'writer_png_Export',\n    jpg: 'writer_jpg_Export',\n    svg: 'writer_svg_Export',\n    html: 'HTML (StarWriter)',\n  },\n  [LOKDocumentType.SPREADSHEET]: {\n    pdf: 'calc_pdf_Export',\n    png: 'calc_png_Export',\n    jpg: 'calc_jpg_Export',\n    svg: 'calc_svg_Export',\n    html: 'HTML (StarCalc)',\n  },\n  [LOKDocumentType.PRESENTATION]: {\n    pdf: 'impress_pdf_Export',\n    png: 'impress_png_Export',\n    jpg: 'impress_jpg_Export',\n    svg: 'impress_svg_Export',\n    html: 'impress_html_Export',\n  },\n  [LOKDocumentType.DRAWING]: {\n    pdf: 'draw_pdf_Export',\n    png: 'draw_png_Export',\n    jpg: 'draw_jpg_Export',\n    svg: 'draw_svg_Export',\n    html: 'draw_html_Export',\n  },\n  [LOKDocumentType.OTHER]: {\n    pdf: 'writer_pdf_Export',\n    png: 'writer_png_Export',\n    jpg: 'writer_jpg_Export',\n    svg: 'writer_svg_Export',\n  },\n};\n\n/**\n * Get the correct export filter for a given output format and document type\n * @param outputFormat The desired output format\n * @param docType The LibreOfficeKit document type (use documentGetDocumentType())\n * @returns The filter name to use for saveAs\n */\nexport function getFilterForDocType(outputFormat: OutputFormat, docType: LOKDocumentType | number): string {\n  // Check if there's a document-type-specific filter\n  const docTypeFilters = DOC_TYPE_FILTERS[docType as LOKDocumentType];\n  if (docTypeFilters && docTypeFilters[outputFormat]) {\n    return docTypeFilters[outputFormat];\n  }\n\n  // Fall back to the default filter\n  return FORMAT_FILTERS[outputFormat];\n}\n\n/**\n * MIME types for output formats\n */\nexport const FORMAT_MIME_TYPES: Record<OutputFormat, string> = {\n  pdf: 'application/pdf',\n  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  doc: 'application/msword',\n  odt: 'application/vnd.oasis.opendocument.text',\n  rtf: 'application/rtf',\n  txt: 'text/plain',\n  html: 'text/html',\n  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  xls: 'application/vnd.ms-excel',\n  ods: 'application/vnd.oasis.opendocument.spreadsheet',\n  csv: 'text/csv',\n  pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n  ppt: 'application/vnd.ms-powerpoint',\n  odp: 'application/vnd.oasis.opendocument.presentation',\n  png: 'image/png',\n  jpg: 'image/jpeg',\n  svg: 'image/svg+xml',\n};\n\n/**\n * File extension to format mapping\n */\nexport const EXTENSION_TO_FORMAT: Record<string, InputFormat> = {\n  doc: 'doc',\n  docx: 'docx',\n  xls: 'xls',\n  xlsx: 'xlsx',\n  ppt: 'ppt',\n  pptx: 'pptx',\n  odt: 'odt',\n  ods: 'ods',\n  odp: 'odp',\n  odg: 'odg',\n  odf: 'odf',\n  rtf: 'rtf',\n  txt: 'txt',\n  html: 'html',\n  htm: 'html',\n  csv: 'csv',\n  xml: 'xml',\n  epub: 'epub',\n  pdf: 'pdf',\n};\n\n/**\n * Map LOK document type to valid output formats\n * This is based on LibreOffice's actual extension maps in desktop/source/lib/init.cxx\n * \n * IMPORTANT: These are the formats that LibreOffice's saveAs() actually supports.\n * The extension maps in init.cxx determine what filters are available per document type.\n * \n * Writer (TEXT): doc, docx, odt, pdf, rtf, txt, html, png, epub\n * Calc (SPREADSHEET): csv, ods, pdf, xls, xlsx, html, png\n * Impress (PRESENTATION): odp, pdf, ppt, pptx, svg, html, png\n * Draw (DRAWING): odg, pdf, svg, html, png\n * \n * NOTE: jpg is NOT in any extension map! Only png is supported for image export.\n * NOTE: svg is only supported for Impress and Draw, not Writer or Calc.\n */\nexport const LOK_DOCTYPE_OUTPUT_FORMATS: Record<LOKDocumentType, OutputFormat[]> = {\n  [LOKDocumentType.TEXT]: ['pdf', 'docx', 'doc', 'odt', 'rtf', 'txt', 'html', 'png'],\n  [LOKDocumentType.SPREADSHEET]: ['pdf', 'xlsx', 'xls', 'ods', 'csv', 'html', 'png'],\n  [LOKDocumentType.PRESENTATION]: ['pdf', 'pptx', 'ppt', 'odp', 'png', 'svg', 'html'],\n  [LOKDocumentType.DRAWING]: ['pdf', 'png', 'svg', 'html'],\n  [LOKDocumentType.OTHER]: ['pdf'],\n};\n\n/**\n * Get valid output formats for a LOK document type\n * Use this after loading a document to get accurate conversion options\n * @param docType The LOK document type (from documentGetDocumentType)\n * @returns Array of valid output formats\n */\nexport function getOutputFormatsForDocType(docType: LOKDocumentType | number): OutputFormat[] {\n  return LOK_DOCTYPE_OUTPUT_FORMATS[docType as LOKDocumentType] || ['pdf'];\n}\n\n/**\n * Map output format to LOK format string\n * These are the format names used by LibreOfficeKit's saveAs\n */\nexport const OUTPUT_FORMAT_TO_LOK: Record<OutputFormat, string> = {\n  pdf: 'pdf',\n  docx: 'docx',\n  doc: 'doc',\n  odt: 'odt',\n  rtf: 'rtf',\n  txt: 'txt',\n  html: 'html',\n  xlsx: 'xlsx',\n  xls: 'xls',\n  ods: 'ods',\n  csv: 'csv',\n  pptx: 'pptx',\n  ppt: 'ppt',\n  odp: 'odp',\n  png: 'png',\n  jpg: 'jpg',\n  svg: 'svg',\n};\n\n/**\n * Filter options for specific format conversions\n * These are passed to LibreOfficeKit's saveAs as the filterOptions parameter\n */\nexport const FORMAT_FILTER_OPTIONS: Partial<Record<OutputFormat, string>> = {\n  // PDF options can include things like:\n  // - SelectPdfVersion (0=PDF 1.4, 1=PDF/A-1, 2=PDF/A-2, 3=PDF/A-3)\n  // - UseLosslessCompression\n  // - Quality\n  pdf: '',\n  // CSV can specify separator, encoding, etc.\n  csv: '44,34,76,1,,0,false,true,false,false,false,-1',\n  // Text encoding\n  txt: 'UTF8',\n};\n\n/**\n * CSV Import filter options for loading CSV files as spreadsheets.\n * \n * The FilterOptions token format (15 tokens, comma-separated):\n * Token 0: Field separator ASCII code (44 = comma, 9 = tab, 59 = semicolon)\n * Token 1: Text delimiter ASCII code (34 = double quote)\n * Token 2: Character set (76 = UTF-8)\n * Token 3: Start row (1 = first row)\n * Token 4: Column format info (empty = auto-detect)\n * Token 5: Language ID (1033 = English US, 0 = system)\n * Token 6: Quoted field as text (true/false)\n * Token 7: Detect special numbers (true/false)\n * Token 8: Save as shown - export only (false)\n * Token 9: Save formulas - export only (false)\n * Token 10: Trim spaces (false)\n * Token 11: Sheet to export - export only (0)\n * Token 12: Evaluate formulas (true)\n * Token 13: Include BOM - export only (false)\n * Token 14: Detect scientific numbers (true)\n * \n * This ensures LibreOffice loads CSV files as Calc spreadsheet documents\n * in headless mode without triggering dialogs.\n */\nexport const CSV_IMPORT_FILTER_OPTIONS = 'FilterName=Text - txt - csv (StarCalc),FilterOptions=44,34,76,1,,1033,false,true,false,false,false,0,true,false,true';\n\n/**\n * Build load options for a document based on format and other options\n * @param inputFormat The input document format\n * @param password Optional password for encrypted documents\n * @returns Load options string for documentLoadWithOptions, or empty string for documentLoad\n */\nexport function buildLoadOptions(inputFormat?: string, password?: string): string {\n  const options: string[] = [];\n  \n  // CSV files need explicit import filter to be recognized as spreadsheets\n  if (inputFormat?.toLowerCase() === 'csv') {\n    options.push(CSV_IMPORT_FILTER_OPTIONS);\n  }\n  \n  // Password-protected documents\n  if (password) {\n    options.push(`Password=${password}`);\n  }\n  \n  return options.join(',');\n}\n\n/**\n * Document type categories for determining valid conversions\n */\nexport type DocumentCategory = 'text' | 'spreadsheet' | 'presentation' | 'drawing' | 'other';\n\n/**\n * Map input formats to their document category\n * This determines which output formats are valid\n */\nexport const INPUT_FORMAT_CATEGORY: Record<InputFormat, DocumentCategory> = {\n  // Text/Writer documents\n  doc: 'text',\n  docx: 'text',\n  odt: 'text',\n  rtf: 'text',\n  txt: 'text',\n  html: 'text',\n  htm: 'text',\n  epub: 'text',\n  xml: 'text',\n  // Spreadsheet/Calc documents\n  xls: 'spreadsheet',\n  xlsx: 'spreadsheet',\n  ods: 'spreadsheet',\n  csv: 'spreadsheet',\n  // Presentation/Impress documents\n  ppt: 'presentation',\n  pptx: 'presentation',\n  odp: 'presentation',\n  // Drawing/Draw documents (PDF imports as Draw)\n  odg: 'drawing',\n  odf: 'drawing',\n  pdf: 'drawing', // PDFs are imported as Draw documents\n};\n\n/**\n * Valid output formats for each document category\n * Based on LibreOffice's actual filter capabilities\n */\nexport const CATEGORY_OUTPUT_FORMATS: Record<DocumentCategory, OutputFormat[]> = {\n  // Writer documents can export to (based on aWriterExtensionMap in init.cxx):\n  // NOTE: jpg and svg are NOT supported for Writer - only png for images\n  text: ['pdf', 'docx', 'doc', 'odt', 'rtf', 'txt', 'html', 'png'],\n  // Calc documents can export to (based on aCalcExtensionMap in init.cxx):\n  // NOTE: jpg and svg are NOT supported for Calc - only png for images\n  spreadsheet: ['pdf', 'xlsx', 'xls', 'ods', 'csv', 'html', 'png'],\n  // Impress documents can export to (based on aImpressExtensionMap in init.cxx):\n  // NOTE: jpg is NOT supported - only png and svg for images\n  presentation: ['pdf', 'pptx', 'ppt', 'odp', 'png', 'svg', 'html'],\n  // Draw documents (including imported PDFs) can export to (based on aDrawExtensionMap in init.cxx):\n  // NOTE: jpg is NOT supported - only png and svg for images\n  drawing: ['pdf', 'png', 'svg', 'html'],\n  // Other/unknown - try PDF only\n  other: ['pdf'],\n};\n\n/**\n * Get valid output formats for a given input format\n * @param inputFormat The input document format\n * @returns Array of valid output formats\n */\nexport function getValidOutputFormats(inputFormat: InputFormat | string): OutputFormat[] {\n  const format = inputFormat.toLowerCase() as InputFormat;\n  const category = INPUT_FORMAT_CATEGORY[format];\n\n  if (!category) {\n    // Unknown format - allow PDF as a safe default\n    return ['pdf'];\n  }\n\n  return CATEGORY_OUTPUT_FORMATS[category];\n}\n\n/**\n * Check if a conversion from input format to output format is valid\n * @param inputFormat The input document format\n * @param outputFormat The desired output format\n * @returns true if the conversion is supported\n */\nexport function isConversionValid(\n  inputFormat: InputFormat | string,\n  outputFormat: OutputFormat | string\n): boolean {\n  const validOutputs = getValidOutputFormats(inputFormat);\n  return validOutputs.includes(outputFormat.toLowerCase() as OutputFormat);\n}\n\n/**\n * Get a human-readable error message for invalid conversions\n * @param inputFormat The input document format\n * @param outputFormat The desired output format\n * @returns Error message explaining why the conversion is not supported\n */\nexport function getConversionErrorMessage(\n  inputFormat: InputFormat | string,\n  outputFormat: OutputFormat | string\n): string {\n  const input = inputFormat.toLowerCase();\n  const output = outputFormat.toLowerCase();\n  const validOutputs = getValidOutputFormats(input as InputFormat);\n\n  const category = INPUT_FORMAT_CATEGORY[input as InputFormat] || 'unknown';\n\n  let reason = '';\n  if (category === 'drawing' && ['docx', 'doc', 'xlsx', 'xls', 'pptx', 'ppt'].includes(output)) {\n    reason = `PDF files are imported as Draw documents and cannot be exported to Office formats. `;\n  } else if (category === 'spreadsheet' && ['docx', 'doc', 'pptx', 'ppt'].includes(output)) {\n    reason = `Spreadsheet documents cannot be converted to word processing or presentation formats. `;\n  } else if (category === 'presentation' && ['docx', 'doc', 'xlsx', 'xls'].includes(output)) {\n    reason = `Presentation documents cannot be converted to word processing or spreadsheet formats. `;\n  } else if (category === 'text' && ['xlsx', 'xls', 'pptx', 'ppt'].includes(output)) {\n    reason = `Text documents cannot be converted to spreadsheet or presentation formats. `;\n  }\n\n  return `Cannot convert ${input.toUpperCase()} to ${output.toUpperCase()}. ${reason}Valid output formats for ${input.toUpperCase()}: ${validOutputs.join(', ')}`;\n}\n\n// ============================================\n// Shared Converter Interface\n// ============================================\n\n/**\n * Page preview data returned by renderPage/renderPagePreviews\n */\nexport interface PagePreview {\n  page: number;\n  data: Uint8Array;\n  width: number;\n  height: number;\n}\n\n/**\n * Document information returned by getDocumentInfo\n */\nexport interface DocumentInfo {\n  documentType: LOKDocumentType | number;\n  documentTypeName: string;\n  validOutputFormats: OutputFormat[];\n  pageCount: number;\n}\n\n/**\n * Options for rendering page previews\n */\nexport interface RenderOptions {\n  /** Width of rendered image in pixels */\n  width?: number;\n  /** Height of rendered image in pixels (0 = auto based on aspect ratio) */\n  height?: number;\n  /** Specific page indices to render (0-based). If empty, renders all pages */\n  pageIndices?: number[];\n  /**\n   * Render in edit mode (shows text input boxes, cursors, etc.)\n   * Default is false - presentations render in view/read mode for clean output\n   */\n  editMode?: boolean;\n}\n\n/**\n * Options for full quality page rendering\n */\nexport interface FullQualityRenderOptions {\n  /** DPI for rendering (default 150, use 300 for print quality) */\n  dpi?: number;\n  /** Maximum dimension (width or height) to prevent memory issues */\n  maxDimension?: number;\n  /**\n   * Render in edit mode (shows text input boxes, cursors, etc.)\n   * Default is false - presentations render in view/read mode for clean output\n   */\n  editMode?: boolean;\n}\n\n/**\n * Full quality page preview with DPI information\n */\nexport interface FullQualityPagePreview extends PagePreview {\n  /** Effective DPI (may differ from requested if capped) */\n  dpi: number;\n}\n\n/**\n * Editor session returned from openDocument\n */\nexport interface EditorSession {\n  sessionId: string;\n  documentType: string;\n  pageCount: number;\n}\n\n/**\n * Result from editor operations\n */\nexport interface EditorOperationResult<T = unknown> {\n  success: boolean;\n  verified?: boolean;\n  data?: T;\n  error?: string;\n  suggestion?: string;\n}\n\n/**\n * Options containing input format for document operations.\n */\nexport type InputFormatOptions = Pick<ConversionOptions, 'inputFormat'>;\n\n/**\n * Common interface for all LibreOffice converter implementations.\n * Ensures consistent API across different threading models (main thread, workers, child processes).\n *\n * All methods returning Promise are async in the interface to allow implementations\n * flexibility in whether they need actual async operations.\n */\nexport interface ILibreOfficeConverter {\n  // ============================================\n  // Lifecycle\n  // ============================================\n\n  /** Initialize the converter. Must be called before any other operations. */\n  initialize(): Promise<void>;\n\n  /** Destroy the converter and release all resources. */\n  destroy(): Promise<void>;\n\n  /** Check if the converter is ready for operations. */\n  isReady(): boolean;\n\n  // ============================================\n  // Core Conversion\n  // ============================================\n\n  /** Convert a document to a different format. */\n  convert(\n    input: Uint8Array | ArrayBuffer,\n    options: ConversionOptions,\n    filename?: string\n  ): Promise<ConversionResult>;\n\n  // ============================================\n  // Document Inspection\n  // ============================================\n\n  /** Get the number of pages in a document. */\n  getPageCount(\n    input: Uint8Array | ArrayBuffer,\n    options: InputFormatOptions\n  ): Promise<number>;\n\n  /** Get document information including type and valid output formats. */\n  getDocumentInfo(\n    input: Uint8Array | ArrayBuffer,\n    options: InputFormatOptions\n  ): Promise<DocumentInfo>;\n\n  // ============================================\n  // Page Rendering\n  // ============================================\n\n  /** Render a single page as an image. */\n  renderPage(\n    input: Uint8Array | ArrayBuffer,\n    options: InputFormatOptions,\n    pageIndex: number,\n    width: number,\n    height?: number\n  ): Promise<PagePreview>;\n\n  /** Render multiple pages as images. */\n  renderPagePreviews(\n    input: Uint8Array | ArrayBuffer,\n    options: InputFormatOptions,\n    renderOptions?: RenderOptions\n  ): Promise<PagePreview[]>;\n\n  /**\n   * Render a page at full quality (native resolution based on DPI).\n   * Unlike renderPage which scales to a fixed width, this renders at the\n   * document's native resolution converted to pixels at the specified DPI.\n   */\n  renderPageFullQuality(\n    input: Uint8Array | ArrayBuffer,\n    options: InputFormatOptions,\n    pageIndex: number,\n    renderOptions?: FullQualityRenderOptions\n  ): Promise<FullQualityPagePreview>;\n\n  // ============================================\n  // Editor Operations\n  // ============================================\n\n  /** Open a document for editing and return a session. */\n  openDocument(\n    input: Uint8Array | ArrayBuffer,\n    options: InputFormatOptions\n  ): Promise<EditorSession>;\n\n  /** Execute an editor operation on an open document. */\n  editorOperation<T = unknown>(\n    sessionId: string,\n    method: string,\n    args?: unknown[]\n  ): Promise<EditorOperationResult<T>>;\n\n  /** Close an editor session and optionally get the modified document. */\n  closeDocument(sessionId: string): Promise<Uint8Array | undefined>;\n}\n"]}